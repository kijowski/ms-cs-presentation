<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Implementacja systemu służącego do zadawania zapytań w postaci grafów pojęć</title>
    <meta name="description" content="Introduction to FsReveal">
    <meta name="author" content="Michał Kijowski">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="//code.jquery.com/jquery-1.8.0.js"></script>
    <script src="//code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">
    <link type="text/css" rel="stylesheet" href="fsharp.formatting/styles/style.css" />
    <link type="text/css" rel="stylesheet" href="fsharp.formatting/styles/deedle.css" />
    <link type="text/css" rel="stylesheet" href="css/custom.css" />
    <script src="fsharp.formatting/styles/tips.js" type="text/javascript"></script>
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/fsreveal.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <script language="javascript" type="text/javascript">
        function init()
        {
            websocket = new WebSocket("ws://"+window.location.host+"/websocket");
            websocket.onmessage = function(evt) { location.reload(); };
        }
        window.addEventListener("load", init, false);
    </script>
</head>
<body>
    <div class="reveal">
        <div class="tip" id="fs1">namespace Microsoft.FSharp.Core</div>

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section >
<h3>Implementacja systemu służącego do zadawania zapytań w postaci grafów pojęć</h3>
</section>
<section >
<section >
<h3>Motywacja</h3>
</section>
<section >
<p>Głównym celem mojej pracy magisterskiej jest utworzenie programu umożliwiającego zadawanie zapytań do relacyjnych baz danych w postaci grafów konceptualnych.</p>
</section>
<section >
<p>W ramach pracy sformułowałem dwa główne zagadnienia badawcze:</p>
<ul>
<li><div class="fragment">Modelowanie wiedzy zawartej w relacyjnej bazie danych przy pomocy grafów konceptualnych</div></li>
<li><div class="fragment">Zadawanie zapytań do relacyjnej bazy danych przy użyciu tak powstałego modelu konceptualnego</div></li>
</ul>
</section>
</section>
<section >
<section >
<h3>Grafy konceptualne</h3>
<aside class="notes">
Wprowadzając pojęcie grafu konceptualnego dobrze jest posłużyć się przykładem<br/>
</aside>
</section>
<section >
<p><img src="images/chapter2_cg_example.jpg" alt="CG" /></p>
<p>Klasyczny przykład grafu konceptualnego reprezentujący wiedzę zawartą w zdaniu <em>John is going to Boston by bus</em>.
<aside class="notes">
Graf konceptualny w postaci wizualnej (<em>Display form</em>)<br/>
</aside></p>
</section>
<section >
<h4>Podstawowe fakty dotyczące grafów konceptualnych</h4>
<ul>
<li><div class="fragment">Modelowanie wiedzy o świecie</div></li>
<li><div class="fragment">Obserwacja świata oparta na dostrzeganiu faktów dotyczących istnienia obiektów</div></li>
</ul>
<aside class="notes">
Dokonując empirycznych obserwacji świata praktycznie niemożliwe jest dostrzeżenie faktów mówiących o nieistnieniu, alternatywie lub stwierdzeniu, iż coś zachodzi we wszystkich przypadkach. Wynika z tego cecha grafów mówiąca o tym, że u ich podstawy stoją kwantyfikator egzystencjalny oraz operator koniunkcji.<br/>
</aside>
</section>
<section >
<h4>Konstrukcja grafu konceptualnego</h4>
<p>Graf konceptualny składa się z wierzchołków dwóch rodzajów:</p>
<ul>
<li><div class="fragment"><strong>Konceptów</strong>, czyli  wierzchołków opisujących byty</div></li>
<li><div class="fragment"><strong>Relacji</strong>, czyli wierzchołków opisujących zależności pomiędzy bytami</div></li>
</ul>
</section>
<section >
<p>Każda relacja jest połączona krawędziami skierowanymi z wierzchołkami konceptualnymi wchodzącymi w skład danej relacji.</p>
<p>Koncepty oraz relacje nazywane są wspólnie pojęciami.</p>
<aside class="notes">
Z technicznego punktu widzenia CG jest grafem dwudzielnym skierowanym<br/>
</aside>
</section>
<section >
<p>Analizując graf konceptualny przedstawiony na rysunku możemy powiedzieć, że składa się on z następujących elementów</p>
</section>
<section >
<p>Prostokątnych wierzchołków opisujących koncepty:</p>
<ul>
<li><div class="fragment">konkretny byt typu Osoba (ang. Person) o identyfikatorze John</div></li>
<li><div class="fragment">konkretny byt typu Miasto (ang. City) o identyfikatorze Boston</div></li>
<li><div class="fragment">niesprecyzowany byt typu Autobus (ang. Bus)</div></li>
<li><div class="fragment">niesprecyzowany byt typu Iść (ang. Go)</div></li>
</ul>
</section>
<section >
<p>Owalnych wierzchołków opisujących relacje pomiędzy powyższymi bytami:</p>
<ul>
<li><div class="fragment">relacja mówiąca o tym, że John jest Wykonawcą (ang. Agent) konceptu Iść</div></li>
<li><div class="fragment">relacja mówiąca o tym, że Autobus jest Narzędziem (ang. Instrument) konceptu Iść</div></li>
<li><div class="fragment">relacja mówiąca o tym, że Boston jest Celem (ang. Destination) konceptu Iść</div></li>
</ul>
</section>
<section >
<h4>Formy zapisu</h4>
<p>Przydatną cechą grafów konceptualnych jest mnogość sposobów ich zapisu.</p>
<p><em>Postać graficzna</em> jest formatem najbardziej przyjaznym dla czytelnika. Jednakże, istnieje również kilka zapisów liniowych, które są dużo przyjaźniejsze dla programów komputerowych pracujących z grafami.</p>
</section>
<section >
<h3>CGIF</h3>
</section>
<section >
<p>Formatem najczęsciej używanym do komunikacji pomiędzy programami wykorzystującymi grafy konceptualne jest format o nazwie <strong>Conceptual Graph Interchange Format</strong>.</p>
<div class="fragment">W ramach projektu Common Logic zostały zdefiniowane w standardzie ISO dwie odmiany formatu CGIF:</div>
<ul>
<li><div class="fragment"><strong>format podstawowy</strong>(ang. <em>core syntax</em>)</div></li>
<li><div class="fragment"><strong>format rozszerzony</strong>(ang. <em>extended syntax</em>)</div></li>
</ul>
<div class="fragment">Obie formy są sobie równoważne - format rozszerzony został wprowadzony wyłącznie w celu uproszczenia zapisu</div>
<aside class="notes">
W ramach formatu CGIF koncepty ujętę są w nawiasy kwadratowe, natomiast relacje - zwykłe nawiasy. Symbole postaci \*x nazywane są etykietami definiującymi, natomiast symbole postaci ?y - etykietami związanymi. Dzięki temu możliwa jest łatwa prezentacja krawędzi grafu.<br/>
</aside>
</section>
<section >
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">Core</span> <span class="i">CGIF</span><span class="o">:</span>
[<span class="o">*</span><span class="i">x</span>] [<span class="o">*</span><span class="i">y</span>]
(<span class="i">Go</span> <span class="o">?</span><span class="i">x</span>) (<span class="i">Person</span> <span class="i">John</span>) (<span class="i">City</span> <span class="i">Boston</span>) (<span class="i">Bus</span> <span class="o">?</span><span class="i">y</span>)
(<span class="i">Agnt</span> <span class="o">?</span><span class="i">x</span> <span class="i">John</span>) (<span class="i">Dest</span> <span class="o">?</span><span class="i">x</span> <span class="i">Boston</span>) (<span class="i">Inst</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">y</span>)

<span class="i">Extended</span> <span class="i">CGIF</span><span class="o">:</span>
[<span class="i">Go</span><span class="o">:</span> <span class="o">*</span><span class="i">x</span>] [<span class="i">Person</span><span class="o">:</span> <span class="i">John</span> <span class="o">*</span><span class="i">y</span>] [<span class="i">City</span><span class="o">:</span> <span class="i">Boston</span> <span class="o">*</span><span class="i">z</span>] [<span class="i">Bus</span><span class="o">:</span> <span class="o">*</span><span class="i">w</span>]
(<span class="i">Agnt</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">y</span>) (<span class="i">Dest</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">z</span>) (<span class="i">Inst</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">z</span>)
</code></pre></td>
</tr>
</table>
</section>
<section >
<h3>CLIF</h3>
</section>
<section >
<p>Kolejnym z liniowych sposobów zapisu jest <strong>Common Logic Interchange Form</strong>, który został zdefiniowany w ramach tego samego projektu co CGIF.</p>
</section>
<section >
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="i">exists</span> ((<span class="o">?</span><span class="i">x</span> <span class="i">Go</span>) (<span class="o">?</span><span class="i">y</span> <span class="i">Person</span>) (<span class="o">?</span><span class="i">z</span> <span class="i">City</span>) (<span class="o">?</span><span class="i">w</span> <span class="i">Bus</span>))
        (<span class="k">and</span> (<span class="i">Name</span> <span class="o">?</span><span class="i">y</span> <span class="i">John</span>) (<span class="i">Name</span> <span class="o">?</span><span class="i">z</span> <span class="i">Boston</span>)
             (<span class="i">Agnt</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">y</span>) (<span class="i">Dest</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">z</span>) (<span class="i">Inst</span> <span class="o">?</span><span class="i">x</span> <span class="o">?</span><span class="i">w</span>)))
</code></pre></td>
</tr>
</table>
</section>
<section >
<h3>Formuła logiczna</h3>
</section>
<section >
<p>Ważną cechą wszystkich grafów konceptualnych jest ich mocne zakorzenienie w logice predykatów, dzięki czemu graf możemy zapisać w postaci formuły logicznej</p>
</section>
<section >
<p><span class="math">\((((\exists\) x:Go)(\(\exists\) y:Person)((\(\exists\) z:City)((\(\exists\) w:Bus)
(name(y,'John') \(\wedge\) name(z,'Boston') \(\wedge\)
agnt(x,y) \(\wedge\) dest(x,z) \(\wedge\) inst(x,w))\)</span></p>
</section>
</section>
<section >
<section >
<h3>Model grafu konceptualnego</h3>
<p>W celu precyzyjnej definicji składni oraz semantyki grafu konceptualnego wprowadza się pojęcie <strong>modelu</strong> (zwanego czasami <strong>słownikiem</strong> lub <strong>wsparciem</strong>), który pozwala opisać syntaktyczne ograniczenia występujące pomiędzy pojęciami oraz dostarcza informacji na temat dziedziny, którą opisuje rozpatrywany graf.</p>
</section>
<section >
<p>Modelem nazywamy krotkę postaci <span class="math">\(M = ((T_C, \le_C), (T_R, \le_R), I)\)</span> gdzie:</p>
<ul>
<li>zbiór <span class="math">\(T_C\)</span> nazywamy zbiorem typów konceptów, natomiast relację <span class="math">\(\le_C\)</span> - hierarchią konceptów.</li>
<li>zbiór <span class="math">\(T_R\)</span> nazywamy zbiorem typów relacji, natomiast relację <span class="math">\(\le_R\)</span> - hierarchią relacji.</li>
<li>zbiór <span class="math">\(I\)</span> nazywamy zbiorem indywiduów.</li>
</ul>
</section>
<section >
<p>Hierarchią nad zbiorem typów konceptów <span class="math">\(T_C\)</span> nazywamy relację częsciowego porządku <span class="math">\(\le_C\)</span> o następujących własnościach</p>
</section>
<section >
<p>Jeśli dla <span class="math">\(x,y \in T_C\)</span> zachodzi <span class="math">\(x \le_C y\)</span> to wówczas mówimy, że <span class="math">\(x\)</span> jest podtypem <span class="math">\(y\)</span>, natomiast <span class="math">\(y\)</span> jest nadtypem x. Dodatkowo jeśli <span class="math">\(x \neq_C y\)</span> to mówimy o podtypie właściwym oraz nadtypie właściwym</p>
</section>
<section >
<p>W zbiorze <span class="math">\(T_C\)</span> istnieją dwa obiekty wyróżnione:</p>
<ul>
<li>obiekt <span class="math">\(\top\)</span> będący elementem maksymalnym porządku <span class="math">\(\le_C\)</span> -  oznacza to, że wszystkie koncepty należące do <span class="math">\(T_C\)</span> są podtypem konceptu <span class="math">\(\top\)</span>. Element <span class="math">\(\top\)</span> nazywamy typem uniwersalnym.</li>
<li>obiekt <span class="math">\(\bot\)</span> będący elementem minimalnym porządku <span class="math">\(\le_C\)</span> - oznacza to, że wszystkie koncepty należące do <span class="math">\(T_C\)</span> są nadtypem konceptu <span class="math">\(\bot\)</span>. Element <span class="math">\(\bot\)</span> nazywamy typem absurdalnym.</li>
</ul>
<aside class="notes">
Należy podkreślić, że w ramach relacji częściowego porządku na typach konceptów nie definiujemy relacji równoważności pomiędzy konceptami.<br/>
Zbiór typów konceptów wraz z hierarchią $(T_C, \le_C)$ jest kratą.<br/>
</aside>
</section>
<section >
<p>Hierarchia nad zbiorem typów konceptów <span class="math">\(T_R = (T_R^1, \ldots , T_R^n)\)</span>, gdzie <span class="math">\(T_R^k\)</span> jest podzbiorem typów relacji o arności równej <span class="math">\(k\)</span>, nazywamy relację częściowego porządku <span class="math">\(\le_R\)</span> o następujących własnościach</p>
</section>
<section >
<p>Jeśli <span class="math">\(x \in T_R^n\)</span>, <span class="math">\(y \in T_R^m\)</span> oraz <span class="math">\(n\neq m\)</span> to wówczas <span class="math">\(x\)</span> oraz <span class="math">\(y\)</span> są nieporównywalne.</p>
</section>
<section >
<p>Jeśli dla <span class="math">\(x,y \in T_R^k\)</span> zachodzi <span class="math">\(x \le_R y\)</span> to wówczas mówimy, że <span class="math">\(x\)</span> jest podtypem <span class="math">\(y\)</span>, natomiast <span class="math">\(y\)</span> jest nadtypem x. Dodatkowo jeśli <span class="math">\(x \neq_R y\)</span> to mówimy o podtypie właściwym oraz nadtypie właściwym</p>
</section>
<section >
<p>Dla każdego ze zbiorów <span class="math">\(T_R^k\)</span>, gdzie <span class="math">\(k=1,\ldots , n\)</span> istnieją dwa obiekty wyróżnione:</p>
<ul>
<li>obiekt <span class="math">\(\top_k\)</span> będący elementem maksymalnym porządku <span class="math">\(\le_C\)</span> ograniczonego do podzbioru <span class="math">\(T_R^k\)</span> - oznacza to, że wszystkie koncepty należące do <span class="math">\(T_R^k\)</span> są podtypem konceptu <span class="math">\(\top_k\)</span>. Element <span class="math">\(\top_k\)</span> nazywamy typem uniwersalnym o arności k.</li>
<li>obiekt <span class="math">\(\bot_k\)</span> będący elementem minimalnym porządku <span class="math">\(\le_C\)</span> ograniczonego do podzbioru <span class="math">\(T_R^k\)</span> - oznacza to, że wszystkie koncepty należące do <span class="math">\(T_R^k\)</span> są nadtypem konceptu <span class="math">\(\bot_k\)</span>. Element <span class="math">\(bot_k\)</span> nazywamy typem absurdalnym o arności k.</li>
</ul>
</section>
<section >
<p>Skończony zbiór <span class="math">\(I\)</span> składający się ze stałych wyrażeń nazywamy zbiorem indywiduów. Każdy element tego zbioru jest reprezentacją konkretnego obiektu należącego do rozpatrywanego uniwersum. Dodatkowo istnieje element <span class="math">\(*\)</span> nazywany indywiduum uniwersalnym. Wówczas zbiór <span class="math">\(M=I\cup \{*\}\)</span> jest uporządkowany w sposób następujący: element <span class="math">\(*\)</span> jest większy niż każdy z elementów należących do <span class="math">\(I\)</span>, natomiast każde dwa elementy <span class="math">\(x,y\in I\)</span> są nieporównywalne.</p>
</section>
</section>
<section >
<section >
<h3>Model relacyjny</h3>
<p>Model relacyjny jest to model organizacji danych zaprezentowany po raz pierwszy w 1970 roku przez Edgara Frank Codda w pracy pt. <em>A Relational Model of Data for Large Shared Data Banks</em></p>
</section>
<section >
<p>Teoretyczną podstawą modelu relacyjnego jest matematyczna teoria mnogości.</p>
<p>Podstawowym pojęciem w modelu relacyjnym jest pojęcie <strong>relacji</strong>, za pomocą którego opisujemy zbiór rekordów (obiektów) o identycznej strukturze wewnętrznej. Obiekty te często przedstawia się w postaci tablicy.</p>
<p>Ustalony zbiór relacji nazywamy <strong>schematem bazy danych</strong>.</p>
</section>
<section >
<p>W modelu relacyjnym każda z relacji (prezentowana w postaci np. tabeli) jest reprezentowana za pomocą trzech parametrów:</p>
<ul>
<li><strong>Nazwa</strong> - opisuje danę relację, musi być unikalna w ramach schematu bazy danych.</li>
<li><strong>Nagłówek</strong> - zbiór artybutów opisujących rekordy wchodzące w skład relacji. Pojedynczy atrybut jest parą składającą się z nazwy oraz typu danego atrybutu.</li>
<li><strong>Zawartość</strong> - zbiór krotek, gdzie pojedyncza krotka opisuje zależności pomiędzy danymi powiązanymi z poszczególnymi atrybutami (np. autorem książki o danym tytule jest osoba o podanym imieniu oraz nazwisku).</li>
</ul>
</section>
<section >
<h3>Klucz główny</h3>
<p>Każda relacja posiada przypisany <strong>klucz główny</strong>, za pomocą którego możliwa jest jednoznaczna identyfikacja dowolnej z krotek wchodzących w skład danej relacji. Klucz główny może być przedstawiony jako kombinacja kilku atrybutów opisujących daną relację. Jednak często spotykaną sytuacją jest klucz główny składający się z jednego atrybutu (np. w przypadku relacji opisującej książki kluczem głównym może być atrybut będący numerem ISBN).</p>
</section>
<section >
<h3>Klucz obcy</h3>
<p>Pojęciem pokrewnym do klucza głównego jest <strong>klucz obcy</strong>. Służy on do wskazywania zależności pomiędzy danymi reprezentującymi różne relacje. Klucze w modelu relacyjnym służą m.in. do sprawdzania spójności danych w bazie.</p>
</section>
<section >
<h3>ALgebra relacyjna</h3>
<p>Kolejnym ważnym elementem modelu relacyjnego jest zbiór operacji służących do manipulacji oraz przeszukiwania danych. Najczęściej zbiór tych operacji opisuje się przy pomocy <strong>algebry relacyjnej</strong>.</p>
</section>
</section>
<section >
<section >
<h3>Analogie pomiędzy grafami konceptualnymi a modelem relacyjnym</h3>
<p>Przed przystąpieniem do głębszej analizy należy spojrzeć na model relacyjny oraz grafy konceptualne z szerszej perspektywy co pozwoli zaobserwować szereg analogii istniejących pomiędzy nimi.</p>
</section>
<section >
<p>Zarówno model relacyjny jak i grafy konceptualne:</p>
<ul>
<li>Mogą być wykorzystywane do modelowania wiedzy o świecie.</li>
<li>Posiadają podstawowe, niepodzielne jednostki wiedzy.</li>
<li>Grupują wspomniane jednostki wiedzy poprzez nakładanie warunków na ich strukturę wewnętrzną.</li>
<li>Umożliwiają wykonywanie szeregu operacji mających na celu manipulacje danymi.</li>
</ul>
</section>
</section>
<section >
<section >
<h3>Generowanie modelu grafów konceptualnych ze schematu relacyjnej bazy danych</h3>
<p>W ramach niniejszej pracy magisterskiej wprowadziłem szereg pojęć rozszerzających teorię grafów konceptualnych. Pojęcia te są bezpośrednio powiązane z modelem relacyjnym, i umożliwiają one łatwiejszy opis opracowanej przeze mnie metody.</p>
</section>
<section >
<h3>Konceptualny typ tablicowy</h3>
<p>Przyjmijmy, że <span class="math">\(r\)</span> jest instancją schematu relacji <span class="math">\(R=\{A_1,\ldots,A_n\}\)</span>. Dodatkowo niech <span class="math">\(r\)</span> składa się ze skończonego zbioru krotek oznaczonego przez <span class="math">\(k\)</span>.
Wówczas możemy stworzyć <strong>Konceptualny Typ Tablicowy</strong> <span class="math">\(T\)</span> o następujących własnościach:</p>
<ul>
<li>Typ <span class="math">\(T_r\)</span> modeluje ten sam typ obiektów co relacja <span class="math">\(r\)</span>.</li>
<li>Z typem <span class="math">\(T_r\)</span> powiązany jest zbiór indywiduów wyznaczony przez zbiór obiektów <span class="math">\(k\)</span> tzn. każdy obiekt z <span class="math">\(k\)</span> ma typ <span class="math">\(T_r\)</span>.</li>
</ul>
</section>
<section >
<h3>Konceptualny Nadtyp Tablicowy</h3>
<p><strong>Konceptualnym Nadtypem Tablicowym</strong> nazywamy specjalny typ wchodzący w skład zbioru typów konceptualnych wyekstrahowanych z danej bazy danych, który posiada następujące właściwości:</p>
<ul>
<li>Dla każdego typu konceptualnego wchodzącego w skład hierarchii konceptów zachodzi następujący warunek - typ konceptualny <span class="math">\(T\)</span> jest podtypem Konceptualnego <strong>Nadtypu Tablicowego</strong> wtedy i tylko wtedy, gdy typ <span class="math">\(T\)</span> jest Konceptualnym Typem Tablicowym wyekstrahowanym z relacji wchodzącej w skład bazy danych.</li>
</ul>
</section>
<section >
<h3>Konceptualny Typ Liczbowy</h3>
<p><strong>Konceptualnym Typem Liczbowym</strong> nazywamy typ opisujący liczby, zarówno całkowite jak i rzeczywiste mogące zostać przedstawione w ramach danej bazy danych.</p>
</section>
<section >
<h3>Konceptualny Typ Napisowy</h3>
<p><strong>Konceptualnym Typem Napisowym</strong> nazywamy typ opisujący napisy mogące zostać przedstawione w ramach danej bazy danych.</p>
</section>
<section >
<h3>Konceptualny Nadtyp Literałowy</h3>
<p><strong>Konceptualnym Nadtypem Literałowym</strong> nazywamy specjalny typ <span class="math">\(L\)</span> wchodzący w skład zbioru typów konceptualnych wyekstrahowanych z danej bazy danych, który jest nadtypem <strong>Konceptualnego Typu Liczbowego</strong> oraz <strong>Konceptualnego Typu Napisowego</strong>.</p>
</section>
<section >
<p><img src="images/KonceptHierarchyPlain.png" alt="CG" /></p>
</section>
<section >
<h3>Relacyjny Typ Kolumnowy</h3>
<p>Przyjmijmy, że <span class="math">\(r\)</span> jest instancją schematu relacji <span class="math">\(R=\{A_1,\ldots,A_n\}\)</span>. Dodatkowo niech <span class="math">\(r\)</span> składa się ze skończonego zbioru krotek oznaczonego przez <span class="math">\(k\)</span>.
Wówczas z relacji <span class="math">\(r\)</span> możemy wyekstrahować zbiór Relacyjnych Typów Kolumnowych <span class="math">\(T_a = \{t_1,\ldots,t_n\}\)</span> o następujących własnościach:</p>
<ul>
<li>Typ relacyjny <span class="math">\(t_i\)</span> modeluje <span class="math">\(i\)</span>-ty atrybut relacji <span class="math">\(r\)</span>.</li>
<li>Typ relacyjny <span class="math">\(t_i\)</span> posiada sygnaturę postaci <span class="math">\(t_i(K_r,L_i)\)</span> gdzie <span class="math">\(K_r\)</span> jest Konceptualnym Typem Tablicowym wyekstrahowanym z relacji <span class="math">\(r\)</span>, natomiast <span class="math">\(L_i\)</span> jest wyróżnionym typem literałowym  wyznaczonym przez domenę atrybutu <span class="math">\(A_i\)</span>.</li>
</ul>
</section>
<section >
<h3>Relacyjny Nadtyp Kolumnowo-Tablicowy</h3>
<p>Relacyjnym Nadtypem Kolumnowo-Tablicowym powiązanym z relacją <span class="math">\(r\)</span> nazywamy specjalny typ relacyjny <span class="math">\(RNK_r\)</span> o sygnaturze <span class="math">\(RNK_r(K_r,L)\)</span> o następujących własnościach:</p>
<ul>
<li><span class="math">\(K_r\)</span> jest Konceptualnym Typem Tablicowym wyekstrahowanym z relacji <span class="math">\(r\)</span>.</li>
<li><span class="math">\(L\)</span> jest Konceptualnym Nadtypem Literałowym.</li>
<li>Każdy Relacyjny Typ Kolumnowy <span class="math">\(R_i\)</span> wyekstrahowany z relacji <span class="math">\(r\)</span> jest podtypem typu <span class="math">\(RNK_r\)</span>.</li>
</ul>
</section>
<section >
<h3>Relacyjny Nadtyp Kolumnowy</h3>
<p>Relacyjnym Nadtypem Kolumnowym nazywamy specjalny typ relacyjny <span class="math">\(RNK\)</span> o sygnaturze <span class="math">\(RNK(K,L)\)</span> o następujących własnościach</p>
<ul>
<li><span class="math">\(K\)</span> jest Konceptualnym Nadtypem Tablicowym.</li>
<li><span class="math">\(L\)</span> jest Konceptualnym Nadtypem Literałowym.</li>
<li>Każdy Relacyjny Nadtyp Kolumnowo-Tablicowy <span class="math">\(RNK_r\)</span> jest podtypem typu <span class="math">\(RNK_r\)</span>.</li>
</ul>
</section>
<section >
<h3>Relacyjny Prosty Typ Złączeniowy</h3>
<p>Przyjmijmy, że <span class="math">\(r\)</span> jest instancją schematu relacji <span class="math">\(R=\{A_1,\ldots,A_n\}\)</span> oraz <span class="math">\(s\)</span> jest instancją schematu relacji <span class="math">\(S=\{B_1,\ldots,B_m\}\)</span>. Dodatkowo niech <span class="math">\(fk=(C_1,\ldots,C_i)\)</span> będzie kluczem obcym łączącym <span class="math">\(R\)</span> oraz <span class="math">\(S\)</span> tzn. <span class="math">\(\forall_{j:1\leq j \leq i} \exists_{l:1\leq l\leq n} A_l=C_j\)</span> oraz <span class="math">\(\forall_{j: 1\leq j \leq i} \exists_{l: 1\leq l\leq m} B_l=C_j\)</span>.
Wówczas Relacyjnym Prostym Typem Złączeniowym <span class="math">\(T\)</span> nazywamy typ relacyjny o następujących własnościach:</p>
</section>
<section >
<p>Typ relacyjny <span class="math">\(T\)</span> modeluje obiekty należące do <span class="math">\(r\)</span> oraz <span class="math">\(s\)</span> będące w relacji <span class="math">\(fk\)</span>.</p>
</section>
<section >
<p>Typ relacyjny <span class="math">\(T\)</span> posiada sygnaturę postaci <span class="math">\(T(K_r,K_s)\)</span> gdzie <span class="math">\(K_r\)</span> jest Konceptualnym Typem Tablicowym wyekstrahowanym z relacji <span class="math">\(r\)</span>, natomiast <span class="math">\(K_s\)</span> jest konceptualnym typem tablicowym wyekstrahowanym z relacji <span class="math">\(s\)</span>.</p>
</section>
<section >
<h3>Relacyjny Złożony Typ Złączeniowy</h3>
<p>Przyjmijmy, że <span class="math">\(R=\{r_1\ldots r_i\}\)</span> jest zbiorem instancji schematów relacji <span class="math">\(T_R=\{R_1\ldots R_i\}\)</span>, oraz <span class="math">\(FK=\{fk_1\ldots fk_{i-1}\}\)</span> jest zbiorem relacyjnych typów złączeniowych gdzie <span class="math">\(\forall k fk_k=(r_k, r_{k+1})\)</span>, czyli <span class="math">\(fk_k\)</span> odpowiada złączeniu relacji <span class="math">\(r_k\)</span> oraz <span class="math">\(r_{k+1}\)</span>.</p>
<p>Możemy wówczas wyróżnić zbiór <span class="math">\(X=\{x_1,\ldots,x_i\}\)</span> gdzie <span class="math">\(x_j\)</span> jest przecięciem obiektów należących do <span class="math">\(r_j\)</span> będących jednocześnie w relacji <span class="math">\(fk_j\)</span> oraz <span class="math">\(fk_{j+1}\)</span>.</p>
<p>Wówczas dla każdego podziału ciągu <span class="math">\((1,\ldots,i)\)</span> na trzy podciągi <span class="math">\((1,\ldots,a),(a+1,\ldots,b),(b+1,\ldots,i)\)</span>, takiego że <span class="math">\(1\leq a\leq b\leq i-1\)</span> możemy zdefiniować Złożony Typ Złączeniowy <span class="math">\(Z\)</span> o następujących własnościach:</p>
</section>
<section >
<p>Typ relacyjny <span class="math">\(Z\)</span> modeluje obiekty należące do <span class="math">\(\{x_1,\ldots,x_a,x_{b+1},\ldots,x_i\}\)</span>.</p>
</section>
<section >
<p>Typ relacyjny <span class="math">\(Z\)</span> posiada sygnaturę postaci <span class="math">\(T(K_1,\ldots,K_a,K_{b+1},\ldots,K_i)\)</span> gdzie <span class="math">\(K_i\)</span> jest Konceptualnym Typem Tablicowym wyekstrahowanym z relacji <span class="math">\(r_i\)</span></p>
</section>
<section >
<p>Z typem relacyjnym <span class="math">\(Z\)</span> związany jest zbiór argumentów ukrytych postaci <span class="math">\((K_{a+1},\ldots,K_{b})\)</span> gdzie <span class="math">\(K_i\)</span> jest Konceptualnym Typem Tablicowym wyekstrahowanym z relacji <span class="math">\(r_i\)</span></p>
</section>
<section >
<p><img src="images/RelationHierarchyPlain.png" alt="CG" /></p>
</section>
<section >
<h3>Opis algorytmu</h3>
<p>Niech <span class="math">\(r\)</span> będzie bazą danych o schemacie <span class="math">\(\mathbb{R}=(R_1,\ldots,R_n)\)</span> gdzie <span class="math">\(R_i\)</span> jest schematem <span class="math">\(i\)</span>-tej relacji. Wówczas algorytm tłumaczący schemat <span class="math">\(\mathbb{R}\)</span> na model grafu konceptualnego składa się z następujących kroków:</p>
</section>
<section >
<p>Inicjalizowane są puste zbiory <span class="math">\(C\)</span>, <span class="math">\(R\)</span> oraz <span class="math">\(I\)</span>, gdzie <span class="math">\(C\)</span> jest zbiorem typów konceptualnych, <span class="math">\(R\)</span> jest zbiorem typów relacyjnych, natomiast <span class="math">\(I\)</span> jest zbiorem indywiduów.</p>
</section>
<section >
<p>Dla każdej relacji <span class="math">\(r_i\in r\)</span> o schemacie <span class="math">\(R_i(A_1,\ldots,A_k)\)</span>:</p>
<ul>
<li>Do zbioru <span class="math">\(C\)</span> dodawany jest Konceptualny Typ Tablicowy utworzony z <span class="math">\(R_i\)</span> zgodnie z definicją.</li>
<li>Do zbioru <span class="math">\(I\)</span> dodawane są obiekty powstałe z kluczy głównych krotek z <span class="math">\(r_i\)</span>.</li>
<li>
Dla każdego atrybutu <span class="math">\(A_j, j\in 1,\ldots,k\)</span>:
<ul>
<li>Do zbioru <span class="math">\(R\)</span> dodawany jest Relacyjny Typ Kolumnowy utworzony z <span class="math">\(R_i\)</span> oraz <span class="math">\(A_j\)</span> zgodnie z definicją.</li>
</ul>
</li>
<li>
Dla każdego klucza obcego <span class="math">\(fk\)</span> zdefiniowanego w ramach <span class="math">\(R_i\)</span>:
<ul>
<li>Do zbioru <span class="math">\(R\)</span> dodawany jest Relacyjny Prosty Typ Złączeniowy utworzony z <span class="math">\(R_i\)</span> oraz tabeli wskazanej przez <span class="math">\(fk\)</span>.</li>
</ul>
</li>
</ul>
</section>
<section >
<p>Tworzony jest graf <span class="math">\(G=(V,E)\)</span> gdzie <span class="math">\(V\)</span> jest zbiorem wierzchołków odpowiadających {Konceptualnym Typom Tablicowym należącym do <span class="math">\(C\)</span>, natomiast <span class="math">\(E\)</span> jest zbiorem krawędzi odpowiadających {Relacyjnym Prostym Typom Złączeniowym należącym do <span class="math">\(R\)</span>.</p>
</section>
<section >
<p>Dla każdej pary wierzchołków <span class="math">\(v_i,v_j\in V\)</span>:</p>
<ul>
<li>Tworzony jest zbiór <span class="math">\(P=(p_1,\ldots,p_m)\)</span> złożony ze wszystkich ścieżek pomiędzy <span class="math">\(v_i\)</span> oraz <span class="math">\(v_j\)</span> w grafie <span class="math">\(G\)</span>.</li>
<li>Dla każdej ścieżki <span class="math">\(p_i\)</span> tworzony jest zbiór Relacyjnych Złożonych Typów Złączeniowych zgodnie z definicją.</li>
<li>Do zbioru <span class="math">\(R\)</span> dodawane są typy uzyskane w poprzednim kroku.</li>
</ul>
</section>
<section >
<p>Zbiory <span class="math">\(C\)</span> oraz <span class="math">\(R\)</span> uzupełniane są typami literałowymi oraz  nadtypami konceptualnymi opisanymi w ramach niniejszej pracy, jednocześnie budując relacje częściowego porządku <span class="math">\(\leq_C\)</span> oraz <span class="math">\(\leq_R\)</span> na tych zbiorach zgodnie z definicjami.</p>
</section>
<section >
<p>Zbiór <span class="math">\(I\)</span> uzupełniany jest o klasy odpowiadające literałom.</p>
</section>
<section >
<p>Zwracany jest model grafu konceptualnego postaci <span class="math">\(M=((C,\leq_C),(R,\leq_R),I)\)</span></p>
</section>
</section>
<section >
<section >
<h3>Zadawanie zapytania do relacyjnej bazy danych przy pomocy Konceptualnego grafu zapytania</h3>
<p>Przed przystąpieniem do definicji <strong>Konceptualnego Grafu Zapytania</strong> należy zrozumieć, dlaczego normalny graf konceptualny nie jest wystarczający w przypadku zadawania zapytania.</p>
</section>
<section >
<p><img src="images/SimpleGraphQuery.png" alt="CG" /></p>
</section>
<section >
<p><img src="images/ComplexGraphQuery.png" alt="CG" /></p>
</section>
<section >
<h3>Konceptualny Graf Zapytania</h3>
<p>Konceptualnym Grafem Zapytania nazywamy krotkę postaci <span class="math">\((G,Q)\)</span>, gdzie <span class="math">\(G\)</span> jest grafem konceptualnym, natomiast <span class="math">\(Q\)</span> jest zbiorem złożonym z wyróżnionych wierzchołków konceptualnych oraz relacyjnych należących do <span class="math">\(G\)</span>.</p>
</section>
<section >
<h3>Zbiór wyników</h3>
<p>Niech <span class="math">\((G,Q)\)</span> będzie Konceptualnym Grafem Zapytania opartym o model <span class="math">\(M=((C,\leq_C),(R,\leq_R),I)\)</span> wyekstrahowanym z relacyjnej bazy danych. Wówczas dla każdego <span class="math">\(q \in Q\)</span> <strong>Zbiorem Wyników</strong> <span class="math">\(R_q\)</span> nazywamy zbiór elementów z <span class="math">\(I\)</span> spełniających jeden z następujących warunków:</p>
</section>
<section >
<p>Jeśli <span class="math">\(q\)</span> jest wierzchołkiem konceptualnym o typie <span class="math">\(T_q\in C\)</span>, to wówczas <span class="math">\(R_q\)</span> składa się z obiektów typu <span class="math">\(T_q\)</span>, które są zgodne z grafem <span class="math">\(G\)</span> tzn. spełniają wszystkie relacje opisane przez <span class="math">\(G\)</span>.</p>
</section>
<section >
<p>Jeśli <span class="math">\(q\)</span> jest wierzchołkiem relacyjnym o typie z sygnaturą <span class="math">\(T_q(A_1,\ldots,A_n)\in R\)</span> to wówczas <span class="math">\(R_q\)</span> składa się z obiektów typu koniunkcyjnego <span class="math">\(T_q=A_1\wedge \ldots \wedge A_n\)</span>. Obiekty należące do <span class="math">\(R_q\)</span> są zgodne z grafem <span class="math">\(G\)</span> tzn. spełniają wszystkie relacje opisane przez <span class="math">\(G\)</span>.</p>
</section>
<section >
<p><img src="images/AutorGraphQuery.png" alt="CG" /></p>
<table>
<thead>
<tr class="header">
<th><p>Imię</p></th>
<th><p>Nazwisko</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Michał</p></td>
<td><p>Kijowski</p></td>
</tr>
<tr class="even">
<td><p>Michał</p></td>
<td><p>Kwiatkowski</p></td>
</tr>
</tbody>
</table>

</section>
<section >
<p><img src="images/JoinGraphQuery.png" alt="CG" /></p>
<table>
<thead>
<tr class="header">
<th><p>Imię</p></th>
<th><p>Nazwisko</p></th>
<th><p>Tytuł</p></th>
<th><p>ISBN</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Michał</p></td>
<td><p>Kijowski</p></td>
<td><p>Pierwsza książka</p></td>
<td><p>1234</p></td>
</tr>
<tr class="even">
<td><p>Michał</p></td>
<td><p>Kijowski</p></td>
<td><p>Druga książka</p></td>
<td><p>5678</p></td>
</tr>
<tr class="odd">
<td><p>Michał</p></td>
<td><p>Kwiatkowski</p></td>
<td><p>Pierwsza książka</p></td>
<td><p>1234</p></td>
</tr>
</tbody>
</table>

</section>
<section >
<h3>Opis algorytmu</h3>
<p>Główna idea algorytmu opiera się na rekurencyjnym zawężaniu zbiorów obiektów zgodnych z danym Konceptualnym Grafem Zapytania.</p>
<p>Mamy dany model konceptualny <span class="math">\(M=((T_C, \leq_{C}),(T_R, \leq_{R}),I)\)</span> oraz oparty na tym modelu Konceptualny Graf Zapytania <span class="math">\((G,Q)\)</span>, gdzie <span class="math">\(G=(C,R,E,lab,coref)\)</span> oraz <span class="math">\(Q=(q_1,\ldots,q_n)\)</span>. Wówczas opisywany algorytm wykonuje następujące kroki:</p>
</section>
<section >
<p>Dla każdego wierzchołka konceptualnego <span class="math">\(c\in C\)</span> o Konceptualnym Typie Tablicowym <span class="math">\(T_c\)</span>:</p>
<ul>
<li>Inicjalizowany jest zbiór <span class="math">\(I_c\)</span> zawierający obiekty z <span class="math">\(I\)</span> o typie <span class="math">\(T_c\)</span>.</li>
</ul>
</section>
<section >
<p>Dla każdego wierzchołka relacyjnego <span class="math">\(r \in R\)</span> o Relacyjnym Typie Kolumnowym:</p>
<ul>
<li>Niech <span class="math">\(c\)</span> oznacza wierzchołek będący argumentem <span class="math">\(r\)</span> o Konceptualnym Typie Tablicowym.</li>
<li>Ze zbioru <span class="math">\(I_c\)</span> elementów powiązanych z wierzchołkiem <span class="math">\(c\)</span> usuwane są elementy, które nie spełniają relacji opisanej przez <span class="math">\(r\)</span>.</li>
</ul>
</section>
<section >
<p>Dla każdego wierzchołka relacyjnego <span class="math">\(r\in R\)</span> posiadającego Relacyjny Typ Złączeniowy:</p>
<ul>
<li>
Dla każdego argumentu relacji <span class="math">\(r\)</span> postaci <span class="math">\(c_i\)</span>:
<ul>
<li>Zbiór <span class="math">\(I_i\)</span> elementów powiązanych z wierzchołkiem <span class="math">\(c_i\)</span> ograniczany jest wyłącznie do elementów, które spełniają relację <span class="math">\(r\)</span>.</li>
</ul>
</li>
</ul>
</section>
<section >
<p>Dla każdego wierzchołka konceptualnego <span class="math">\(c\in Q\)</span> o Konceptualnym Typie Tablicowym:</p>
<ul>
<li>Inicjalizowany jest zbiór <span class="math">\(W_c\)</span> równy zbiorowi <span class="math">\(I_c\)</span>.</li>
</ul>
</section>
<section >
<p>Dla każdego wierzchołka relacyjnego <span class="math">\(r \in Q\)</span> o Relacyjnym Typie Kolumnowym:</p>
<ul>
<li>Niech <span class="math">\(c\)</span> oznacza wierzchołek będący argumentem <span class="math">\(r\)</span> o Konceptualnym Typie Złączeniowym.</li>
<li>Inicjalizowany jest zbiór <span class="math">\(W_r\)</span> równy zbiorowi <span class="math">\(I_c\)</span> elementów powiązanych z wierzchołkiem <span class="math">\(c\)</span>.</li>
</ul>
</section>
<section >
<p>Dla każdego wierzchołka relacyjnego <span class="math">\(r\in Q\)</span> posiadającego Relacyjny Typ Złączeniowy:</p>
<ul>
<li>Niech <span class="math">\(c_1,\ldots,c_j,c_k,\ldots,c_n\)</span> będą wierzchołkami będącymi argumentami relacji <span class="math">\(r\)</span>.</li>
<li>Inicjalizowany jest zbiór <span class="math">\(W_r\)</span> złożony z obiektów postaci <span class="math">\(a=(a_1,\ldots,a_j,a_K,\ldots,a_n)\)</span> gdzie <span class="math">\(a_i\in I_i\)</span> takich, że <span class="math">\(a\)</span> spełnia relacje <span class="math">\(r\)</span>.</li>
</ul>
</section>
<section >
<p>Zwracany jest zbiór Zbiorów Wyników <span class="math">\(W=\{W_i | i\in Q\}\)</span></p>
</section>
</section>
<section >
<section >
<h3>Konlator</h3>
</section>
<section >
<p><img src="images/ProgramArch.png" alt="CG" /></p>
</section>
</section>
<section >
<p>Dziękuję za uwagę!</p>
</section>


        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
        // Add the nohighlight class and data-noescape attribute to code elements that have already been formatted by FSharp.Formatting
        $('pre.highlighted code').addClass('nohighlight').attr('data-noescape', '');

        // Full list of configuration options available here:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

            // Parallax scrolling
            // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
            // parallaxBackgroundSize: '2100px 900px',

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
                { src: 'plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
            ]
        });

    </script>
</body>
</html>

